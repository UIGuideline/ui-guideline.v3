---
import { docsComponents } from '@docs';
import { ComponentDetailLayout } from '@layouts';
import { getCollection, render } from 'astro:content';

interface StaticPathProps {
	entryId: string;
}

export async function getStaticPaths() {
	const docs = await getCollection('overviewDocs');

	return docs.map((entry) => ({
		params: { slug: entry.id },
		props: { entryId: entry.id },
	}));
}

const { entryId } = Astro.props as StaticPathProps;

const allDocs = await getCollection('overviewDocs');
const entry = allDocs.find((doc) => doc.id === entryId);

if (!entry) {
	throw new Error(`Overview doc not found: ${entryId}`);
}

const { Content } = await render(entry);

/**
 * Extract headings from MDX body for Table of Contents
 * Matches # heading syntax in the raw MDX content
 */
function extractHeadings(body: string): Array<{ id: string; label: string; level?: number }> {
	const headingRegex = /^(#{1,6})\s+(.+)$/gm;
	const headings: Array<{ id: string; label: string; level?: number }> = [];
	let match: RegExpExecArray | null;

	while ((match = headingRegex.exec(body)) !== null) {
		const level = match[1]!.length;
		const text = match[2]!.trim();

		// Skip h1 (usually the page title)
		if (level === 1) continue;

		// Generate slug from heading text (simple version)
		const id = text
			.toLowerCase()
			.replace(/[^a-z0-9\s-]/g, '')
			.replace(/\s+/g, '-')
			.replace(/-+/g, '-')
			.trim();

		headings.push({
			id,
			label: text,
			level,
		});
	}

	return headings;
}

const toc = extractHeadings(entry.body ?? '');
---

<ComponentDetailLayout
	title={`${entry.data.title} | UI Guideline`}
	description={entry.data.description}
	currentSlug={entry.id}
	toc={toc}
	section="overview"
>
	<article class="max-w-none">
		<Content components={docsComponents} />
	</article>
</ComponentDetailLayout>
